generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ======================== USUÁRIOS ========================

model User {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  password  String
  avatar    String?
  pixKey    String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  home      Home?    @relation(fields: [homeId], references: [id])
  homeId    String?
  isAdmin   Boolean  @default(false)

  expensesPaid    Expense[]       @relation("PaidBy")
  expenseShares   ExpenseShare[]
  itemsAdded      ShoppingItem[]  @relation("AddedBy")
  itemsPurchased  ShoppingItem[]  @relation("PurchasedBy")
  itemNotes       ItemNote[]

  @@map("users")
}

// ======================== CASA ========================

model Home {
  id         String   @id @default(cuid())
  name       String
  inviteCode String   @unique @default(cuid())
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  members       User[]
  categories    Category[]
  expenses      Expense[]
  shoppingLists ShoppingList[]

  @@map("homes")
}

// ======================== CATEGORIAS ========================

model Category {
  id           String       @id @default(cuid())
  name         String
  icon         String
  color        String
  type         CategoryType @default(VARIABLE)
  isRecurring  Boolean      @default(false)
  recurringDay Int?

  home     Home      @relation(fields: [homeId], references: [id], onDelete: Cascade)
  homeId   String
  expenses Expense[]

  @@map("categories")
}

enum CategoryType {
  FIXED
  VARIABLE
  ONETIME
}

// ======================== DESPESAS ========================

model Expense {
  id          String    @id @default(cuid())
  description String
  amount      Float
  date        DateTime  @default(now())
  dueDate     DateTime?
  receipt     String?
  notes       String?
  splitType   SplitType @default(EQUAL)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  paidBy     User     @relation("PaidBy", fields: [paidById], references: [id])
  paidById   String
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String
  home       Home     @relation(fields: [homeId], references: [id], onDelete: Cascade)
  homeId     String
  shares     ExpenseShare[]

  @@map("expenses")
}

enum SplitType {
  EQUAL
  CUSTOM
  INDIVIDUAL
}

// ======================== DIVISÃO DAS DESPESAS ========================

model ExpenseShare {
  id        String    @id @default(cuid())
  amount    Float
  isPaid    Boolean   @default(false)
  paidAt    DateTime?

  expense   Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  expenseId String
  user      User    @relation(fields: [userId], references: [id])
  userId    String

  @@unique([expenseId, userId])
  @@map("expense_shares")
}

// ======================== LISTA DE COMPRAS ========================

model ShoppingList {
  id       String           @id @default(cuid())
  name     String
  type     ShoppingListType @default(SIMPLE)
  isActive Boolean          @default(true)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  home   Home           @relation(fields: [homeId], references: [id], onDelete: Cascade)
  homeId String
  items  ShoppingItem[]

  @@map("shopping_lists")
}

enum ShoppingListType {
  SIMPLE
  WISHLIST
}

// ======================== ITENS DA LISTA ========================

model ShoppingItem {
  id             String     @id @default(cuid())
  name           String
  description    String?
  quantity       Int        @default(1)
  isPurchased    Boolean    @default(false)
  purchasedAt    DateTime?
  
  targetPriceMin  Float?
  targetPriceMax  Float?
  currentPrice    Float?
  lowestPrice     Float?
  lowestPriceUrl  String?
  lowestPriceDate DateTime?
  
  status      ItemStatus @default(PENDING)
  priority    Priority   @default(MEDIUM)
  alertOnPrice Boolean    @default(true)
  alertSent    Boolean    @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  list          ShoppingList  @relation(fields: [listId], references: [id], onDelete: Cascade)
  listId        String
  addedBy       User          @relation("AddedBy", fields: [addedById], references: [id])
  addedById     String
  purchasedBy   User?         @relation("PurchasedBy", fields: [purchasedById], references: [id])
  purchasedById String?
  urls          ProductUrl[]
  priceHistory  PriceHistory[]
  notes         ItemNote[]

  @@map("shopping_items")
}

enum ItemStatus {
  PENDING
  WATCHING
  IN_RANGE
  PURCHASED
  CANCELLED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// ======================== URLs DOS PRODUTOS ========================

model ProductUrl {
  id        String    @id @default(cuid())
  url       String
  store     String
  lastPrice Float?
  lastCheck DateTime?
  isActive  Boolean   @default(true)

  item   ShoppingItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  itemId String

  @@map("product_urls")
}

// ======================== HISTÓRICO DE PREÇOS ========================

model PriceHistory {
  id         String   @id @default(cuid())
  price      Float
  url        String
  store      String
  capturedAt DateTime @default(now())

  item   ShoppingItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  itemId String

  @@map("price_history")
}

// ======================== NOTAS DOS ITENS ========================

model ItemNote {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())

  item     ShoppingItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  itemId   String
  author   User         @relation(fields: [authorId], references: [id])
  authorId String

  @@map("item_notes")
}